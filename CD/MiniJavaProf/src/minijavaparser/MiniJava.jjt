options
{
	LOOKAHEAD = 1;
	FORCE_LA_CHECK = true;
	CHOICE_AMBIGUITY_CHECK = 2;
	OTHER_AMBIGUITY_CHECK = 1;
	DEBUG_PARSER = true;
	
	TRACK_TOKENS = true;
	TOKEN_EXTENDS = "progen.Entity";
	
	NODE_CLASS = "progen.ProgenNode";
	NODE_EXTENDS = "progen.Entity";

	MULTI = true;
	VISITOR = true;
	NODE_DEFAULT_VOID = true;
}

PARSER_BEGIN(MiniJava)
package minijavaparser;

import java.io.*;

public class MiniJava
{	
	public static void main(String args[]) 
	{
	    System.err.println("Reading from standard input...");
	    try 
	    {
	      	MiniJava p = new MiniJava(new FileInputStream(new File("./samples/test01.java")));
	    	ASTProgram root = p.Program();
	    	root.dump(">");
			System.out.println("Thank you.");
	    } 
	    catch (Exception e) 
	    {									      
			System.err.println("Oops.");
			System.err.println(e.getMessage());
			e.printStackTrace();
	    }
	}
}
PARSER_END(MiniJava)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN : /* KEYWORDS */
{
  <CLASS: "class">
| <PUBLIC: "public">
| <STATIC: "static">
| <VOID: "void">
| <MAIN: "main">
| <STRING: "String">
| <EXTENDS: "extends">
| <IF: "if">
| <ELSE: "else">
| <WHILE: "while">
| <PRINTLN: "System.out.println">
| <RETURN: "return">
| <INT: "int">
| <BOOLEAN: "boolean">
| <LENGTH: "length">
| <TRUE: "true">
| <FALSE: "false">
| <THIS: "this">
| <NEW: "new">
} 

TOKEN : /* IDENTIFIERS */
{
  < ID: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER: ["_","a"-"z","A"-"Z"] >
|
  < #DIGIT: ["0"-"9"] >
}

TOKEN : /* OPERATORS */
{
  < BINARYOPERATOR: ["+","-","*","/"] > |
  < ASSIGNOPERATOR: ":=" >
}

TOKEN : /* SEPARATORS */
{
  <LBRACKET: "[">
| <RBRACKET: "]">
| <LPAREN: "(">
| <RPAREN: ")">
| <LACCOLADE: "{">
| <RACCOLADE: "}">
| <COMMA: ",">
| <SEMICOLON: ";">
}

ASTProgram Program() #Program:
{
}
{
	MainClass() ( ClassDecl() )* <EOF>
  	{
  		return jjtThis; 
  	}
}

void MainClass() #MainClass:
{
}
{ 
	"class" Identifier()
	"{"
		"public" "static" "void" "main" "(" "String" "[" "]" Identifier() ")"
		"{"
			Statement()
		"}"
	"}"
}

void ClassDecl() #ClassDecl:
{
}
{
	"class" Identifier() [ "extends" Identifier() ] "{" (VarDecl())* (MethodDecl())* "}"
}

void VarDecl() #VarDecl:
{
}
{
	Type() Identifier() ";" 
}

void MethodDecl() #MethodDecl:
{
}
{
  	"public" Type() Identifier() "(" FormalList() ")"
  	"{"
  	  	(VarDecl())*
  	  	//(Statement())*
  	  	"return" Expression() ";"  	"}" 
}

void FormalList() #FormalList:
{
}
{
  	Type() Identifier() ("," Type() Identifier())*
}

void Type() #Type:
{
}
{
	"int" [ "[" "]" ]
	| "boolean"
	| Identifier()
}

void Statement() #Statement:
{
}
{
  	"{" (Statement())* "}"
 	| "if" "(" Expression() ")" Statement() "else" Statement()
 	| "while" "(" Expression() ")" Statement()
 	| "System.out.println" "(" Expression() ")" ";"
 	| Identifier() [ "[" Expression() "]" ] "=" Expression() ";" 
}

void ExpressionList() #ExpressionList:
{
}
{
  	Expression() ("," Expression())*
}

void Expression() #Expression:
{}
{
	Identifier()}

void Identifier() #Identifier:
{
}
{
	<ID>
}
