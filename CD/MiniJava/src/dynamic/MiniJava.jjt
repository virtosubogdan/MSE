options{  LOOKAHEAD= 3;  FORCE_LA_CHECK = true;  CHOICE_AMBIGUITY_CHECK = 2;  OTHER_AMBIGUITY_CHECK = 1;  DEBUG_PARSER = true;  TRACK_TOKENS = true;  MULTI = true;  VISITOR = true;  NODE_DEFAULT_VOID = true;}PARSER_BEGIN(MiniJava)package dynamic;import java.io.*;public class MiniJava{}PARSER_END(MiniJava)SKIP :{  " "| "\t"| "\n"| "\r"}TOKEN : /* KEYWORDS */{  < CLASS : "class" >| < PUBLIC : "public" >| < STATIC : "static" >| < VOID : "void" >| < MAIN : "main" >| < STRING : "String" >| < EXTENDS : "extends" >| < IF : "if" >| < ELSE : "else" >| < WHILE : "while" >| < PRINTLN : "System.out.println" >| < RETURN : "return" >| < INT : "int" >| < BOOLEAN : "boolean" >| < LENGTH : "length" >| < TRUE : "true" >| < FALSE : "false" >| < THIS : "this" >| < NEW : "new" >}TOKEN : /* IDENTIFIERS */{  < ID :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < INTEGERLITERAL : "0" |["1"-"9"] (< DIGIT >)* >| < #LETTER : [ "_", "a"-"z", "A"-"Z" ] >| < #DIGIT : [ "0"-"9" ] >}TOKEN : /* OPERATORS */{  < BINARYOPERATOR : [ "+", "-", "*", "/" ] >| < ASSIGNOPERATOR : ":=" >}TOKEN : /* SEPARATORS */{  < LBRACKET : "[" >| < RBRACKET : "]" >| < LPAREN : "(" >| < RPAREN : ")" >| < LACCOLADE : "{" >| < RACCOLADE : "}" >| < COMMA : "," >| < SEMICOLON : ";" >}ASTProgram Program() #Program :{}{  MainClass()  (    ClassDecl()  )*  < EOF >  {    return jjtThis;  }}void MainClass() #MainClass :{}{  "class" Identifier() "{" "public" "static" "void" "main" "(" "String" "[" "]" Identifier() ")" "{" Statement() "}" "}"}void ClassDecl() #ClassDecl :{}{  "class" Identifier() [ "extends" Identifier() ] "{"  (    VarDecl()  )*  (    MethodDecl()  )*  "}"}void VarDecl() #VarDecl :{}{  Type() Identifier() ";"}void MethodDecl() #MethodDecl :{}{  "public" Type() Identifier() "(" [ FormalList() ] ")" "{"  (    VarDecl()  )*  (Statement())*
  "return" Expression() ";" "}"}void FormalList() #FormalList :{}{  Type() Identifier()  (    "," Type() Identifier()  )*}void Type() #Type :{}{  "int" [ "[" "]" ]| "boolean"| Identifier()}void Statement() #Statement :{}{  "{"  (    Statement()  )*  "}"| "if" "(" Expression() ")" Statement() "else" Statement()| "while" "(" Expression() ")" Statement()| "System.out.println" "(" Expression() ")" ";"| Identifier() [ "[" Expression() "]" ] "=" Expression() ";"}void ExpressionList() #ExpressionList :{}{  Expression()  (    "," Expression()  )*}void Expression() #Expression :{}{  ExpressionBegin()  [    Op() Expression()  | < LBRACKET > Expression() < RBRACKET >  | "." Call()  ]}void Call() #Call :{}{  < LENGTH >| Identifier() < LPAREN > [ ExpressionList() ] < RPAREN >}void ExpressionBegin() #ExpressionBegin :{}{  IntegerLiteral()| < TRUE>| < FALSE>|   Identifier()| < THIS >| < NEW > Creation()| "!" Expression()| < LPAREN > Expression() < RPAREN >}void IntegerLiteral() #IntegerLiteral :{}{  < INTEGERLITERAL >}void Creation() #Creation :{}{  < INT > < LBRACKET > Expression() < RBRACKET >| Identifier() < LPAREN > < RPAREN >}void Op() #Op :{}{  < BINARYOPERATOR >| < ASSIGNOPERATOR >}void Identifier() #Identifier :{}{  < ID >}
